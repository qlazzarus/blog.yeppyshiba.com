---
import BaseHead from '@/components/BaseHead.astro';
import Footer from '@/components/Footer.astro';
import Header from '@/components/Header.astro';
import { SITE_LANG } from '@/consts';
import '@/styles/global.css';

const { title, description } = Astro.props;
---

<html lang={SITE_LANG}>
    <head>
        <BaseHead title={title} description={description} />
        <script is:inline>
            // Early theme init to prevent flash (FOUC)
            (function () {
                try {
                    const saved = localStorage.getItem('theme'); // 'dark' | 'light' | null
                    const prefersDark = window.matchMedia(
                        '(prefers-color-scheme: dark)',
                    ).matches;
                    const theme = saved || (prefersDark ? 'dark' : 'light');
                    const root = document.documentElement;
                    if (theme === 'dark') root.classList.add('dark');
                    else root.classList.remove('dark');
                } catch {}
            })();
        </script>
        <!-- âœ… Google tag (gtag.js) -->
        <script async src='https://www.googletagmanager.com/gtag/js?id=G-P6NE4VJRLC'
        ></script>
        <script is:inline>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag('js', new Date());
            gtag('config', 'G-P6NE4VJRLC');
        </script>
    </head>

    <body
        class='bg-bg text-fg flex min-h-screen flex-col transition-colors duration-150'
    >
        <Header />
        <main class='container mx-auto max-w-5xl flex-1 px-4 py-8'>
            <slot />
        </main>
        <Footer />

        <script type='module'>
            // Build an improved TOC from headings inside the article prose.
            document.addEventListener('DOMContentLoaded', () => {
                const content =
                    document.querySelector('main .prose-xl') ||
                    document.querySelector('.prose-xl');
                const tocEl = document.getElementById('toc');
                if (!content || !tocEl) return;

                // Clear any existing TOC
                tocEl.innerHTML = '';

                const headings = Array.from(content.querySelectorAll('h2, h3, h4'));
                if (!headings.length) return;

                function slugify(text) {
                    return text
                        .trim()
                        .toLowerCase()
                        .replace(/\s+/g, '-')
                        .replace(/[^\w-]/g, '');
                }

                const rootUl = document.createElement('ul');
                rootUl.className = 'space-y-1';

                // Simple nested list builder based on heading level
                let stack = [{ level: 2, el: rootUl }];

                headings.forEach((h) => {
                    if (!h.textContent) return;
                    if (!h.id) h.id = slugify(h.textContent);

                    const level = Number(h.tagName.slice(1));
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = `#${h.id}`;
                    a.textContent = h.textContent;
                    a.className =
                        'text-sm text-muted-foreground hover:text-foreground hover:underline block';
                    a.dataset.target = h.id;
                    a.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (h.id) {
                            const target = document.getElementById(h.id);
                            if (target)
                                target.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'start',
                                });
                            // update hash without jumping
                            history.replaceState(null, '', `#${h.id}`);
                        }
                    });
                    li.appendChild(a);

                    // find appropriate parent in stack
                    let parent = stack[0];
                    if (level > parent.level) {
                        // create nested list under previous li
                        const lastLi = parent.el.lastElementChild;
                        const newUl = document.createElement('ul');
                        newUl.className = 'ml-4 space-y-1';
                        if (lastLi) lastLi.appendChild(newUl);
                        stack.unshift({ level, el: newUl });
                        parent = stack[0];
                    } else {
                        while (stack.length && level < stack[0].level) stack.shift();
                        parent = stack[0] || { level, el: rootUl };
                        if (level > parent.level) {
                            const newUl = document.createElement('ul');
                            newUl.className = 'ml-4 space-y-1';
                            parent.el.appendChild(newUl);
                            stack.unshift({ level, el: newUl });
                            parent = stack[0];
                        }
                    }

                    parent.el.appendChild(li);
                });

                tocEl.appendChild(rootUl);

                // observe headings to mark active TOC item
                const links = Array.from(tocEl.querySelectorAll('a[data-target]'));
                const idToLink = new Map();
                links.forEach((l) => idToLink.set(l.dataset.target || '', l));

                const observer = new IntersectionObserver(
                    (entries) => {
                        entries.forEach((entry) => {
                            const id = entry.target.id;
                            const link = idToLink.get(id);
                            if (!link) return;
                            if (entry.isIntersecting) {
                                // clear others
                                links.forEach((ln) =>
                                    ln.classList.remove(
                                        'font-semibold',
                                        'text-foreground',
                                    ),
                                );
                                link.classList.add('font-semibold', 'text-foreground');
                            }
                        });
                    },
                    { root: null, rootMargin: '0px 0px -60% 0px', threshold: 0 },
                );

                headings.forEach((h) => observer.observe(h));

                // Initialize highlight.js on code blocks
                if (window.hljs) {
                    document.querySelectorAll('pre code').forEach((block) => {
                        window.hljs.highlightElement(block);
                    });
                }
            });
        </script>
        <script is:inline>
            (function () {
                const root = document.documentElement;
                const btn = document.getElementById('theme-toggle');
                const label = document.getElementById('theme-label');

                function currentIsDark() {
                    return root.classList.contains('dark');
                }
                function setTheme(dark) {
                    if (dark) root.classList.add('dark');
                    else root.classList.remove('dark');
                    try {
                        localStorage.setItem('theme', dark ? 'dark' : 'light');
                    } catch {}
                    updateLabel();
                }
                function updateLabel() {
                    if (!label) return;
                    if (currentIsDark()) {
                        label.textContent = 'ðŸŒ™ Dark';
                    } else {
                        label.textContent = 'ðŸŒž Light';
                    }
                }

                // initialize label on load
                updateLabel();

                btn?.addEventListener('click', () => setTheme(!currentIsDark()));

                // Optional: keep in sync if user changes OS theme and no explicit preference saved
                try {
                    const mq = window.matchMedia('(prefers-color-scheme: dark)');
                    mq.addEventListener?.('change', (e) => {
                        const saved = localStorage.getItem('theme');
                        if (!saved) {
                            // only follow system if user hasn't chosen
                            setTheme(!!e.matches);
                        }
                    });
                } catch {}
            })();
        </script>
    </body>
</html>
