1:"$Sreact.fragment"
3:I[5244,[],""]
4:I[3866,[],""]
6:I[6213,[],"OutletBoundary"]
8:I[6213,[],"MetadataBoundary"]
a:I[6213,[],"ViewportBoundary"]
c:I[4835,[],""]
:HL["/_next/static/media/47cbc4e2adbc5db9-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/acfb4e572a721580.css","style"]
0:{"P":null,"b":"GMP_58STJf1i37uJRngK1","p":"","c":["","article","image-drm-implementation",""],"i":false,"f":[[["",{"children":["article",{"children":[["slug","image-drm-implementation","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/acfb4e572a721580.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],"$L2"]}],{"children":["article",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","article","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","image-drm-implementation","d"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","article","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":"$L7"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","GbKiL6u1MWdRPBx0b17as",{"children":[["$","$L8",null,{"children":"$L9"}],["$","$La",null,{"children":"$Lb"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$c","$undefined"],"s":false,"S":true}
d:I[6269,["967","static/chunks/967-1bc8bd5ae145cc41.js","33","static/chunks/33-b54d5da5beda4fc8.js","177","static/chunks/app/layout-11cb33ab0676062e.js"],"default"]
e:I[4527,["967","static/chunks/967-1bc8bd5ae145cc41.js","33","static/chunks/33-b54d5da5beda4fc8.js","177","static/chunks/app/layout-11cb33ab0676062e.js"],"default"]
f:I[1392,["967","static/chunks/967-1bc8bd5ae145cc41.js","33","static/chunks/33-b54d5da5beda4fc8.js","177","static/chunks/app/layout-11cb33ab0676062e.js"],"default"]
10:I[457,["967","static/chunks/967-1bc8bd5ae145cc41.js","33","static/chunks/33-b54d5da5beda4fc8.js","177","static/chunks/app/layout-11cb33ab0676062e.js"],"default"]
11:I[766,["967","static/chunks/967-1bc8bd5ae145cc41.js","33","static/chunks/33-b54d5da5beda4fc8.js","177","static/chunks/app/layout-11cb33ab0676062e.js"],"GoogleAnalytics"]
2:["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"children":[[["$","script","mui-color-scheme-init",{"suppressHydrationWarning":true,"nonce":"$undefined","dangerouslySetInnerHTML":{"__html":"(function() {\ntry {\n  let colorScheme = '';\n  const mode = localStorage.getItem('mui-mode') || 'system';\n  const dark = localStorage.getItem('mui-color-scheme-dark') || 'dark';\n  const light = localStorage.getItem('mui-color-scheme-light') || 'light';\n  if (mode === 'system') {\n    // handle system mode\n    const mql = window.matchMedia('(prefers-color-scheme: dark)');\n    if (mql.matches) {\n      colorScheme = dark\n    } else {\n      colorScheme = light\n    }\n  }\n  if (mode === 'light') {\n    colorScheme = light;\n  }\n  if (mode === 'dark') {\n    colorScheme = dark;\n  }\n  if (colorScheme) {\n    document.documentElement.classList.remove('%s'.replace('%s', light), '%s'.replace('%s', dark));\n      document.documentElement.classList.add('%s'.replace('%s', colorScheme));document.documentElement.setAttribute('.%s', colorScheme);\n  }\n} catch(e){}})();"}}]],["$","$Ld",null,{"children":["$","$Le",null,{"theme":"$f","defaultMode":"system","children":[["$","$L10",null,{"enableColorScheme":true}],["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]]}]}],["$","$L11",null,{"gaId":"G-P6NE4VJRLC"}]]}]}]
12:I[4933,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
13:I[787,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
14:I[1309,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
15:I[9595,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
18:I[5436,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
19:I[7013,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
1a:I[8173,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],""]
1b:I[9234,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
1c:I[2282,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
1d:I[6656,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
1e:I[3345,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
1f:I[9561,["967","static/chunks/967-1bc8bd5ae145cc41.js","337","static/chunks/337-18f19de510d1d53b.js","467","static/chunks/467-8c7bc18aa09eb692.js","234","static/chunks/234-4d7c2d5758e6aea9.js","48","static/chunks/48-228feae1d1feafc8.js","355","static/chunks/355-9f6e8ed93740a9d3.js","225","static/chunks/app/article/%5Bslug%5D/page-b62baeaa5c1731ae.js"],"default"]
16:T2485,
# 이미지 DRM 구현을 위한 커스텀 컨테이너 접근

이 글에서는 **이미지 DRM**(Digital Rights Management)을 간단히 구현하기 위한 방법으로, **커스텀 컨테이너 포맷**을 사용하는 과정을 살펴봅니다. 일반적인 PNG/JPEG 파일을 그대로 제공하면 네트워크 트래픽을 훔쳐보거나(패킷 스니핑, HTTP 후킹 등) 직접 다운로드해 무단으로 사용하는 경우가 발생할 수 있습니다. 이러한 문제를 방지하기 위해, **이미지를 암호화하여 커스텀 포맷으로 제공**하고, 클라이언트(앱, 웹)에서만 복호화해 볼 수 있도록 하는 방식을 소개합니다.

## DRM 개념과 필요성

- **DRM(Digital Rights Management)**: 디지털 콘텐츠(이미지, 동영상, 문서 등)를 무단으로 복제·배포·수정하는 행위를 방지하는 기술입니다.
- **문제 상황**:
    1. 일반 JPEG/PNG로 이미지를 제공하면, 단순 URL 접근으로 다운로드가 가능합니다.
    2. 네트워크 트래픽을 후킹(스니핑)하여 이미지를 추출할 수 있습니다.
- **해결 방향**:
    - **커스텀 포맷** 및 **암호화**를 적용하여, 표준 뷰어나 일반적인 방법으로는 파일을 열 수 없게 만듭니다.
    - 클라이언트는 인증된 환경에서만 **복호화 키**를 얻어 이미지를 표시할 수 있게 합니다.

---

## 커스텀 컨테이너 포맷 설계

### 1. 기본 구조

**파일(컨테이너) 헤더**:

- **매직 넘버**: 파일 식별을 위한 고유 문자열, 예: \`"CIMG"\`.
- **버전**: 포맷 버전 관리용 (정수).
- **암호화 방식**: AES, 기타 등등.
- **예약 영역**: 차후 확장을 위해 남겨둔 영역.

**파일 바디**:

- **암호화된 이미지 데이터**: 복호화 전까진 원본 이미지를 열람할 수 없습니다.

### 2. 흐름 요약

1. **서버**

    1. 원본 이미지를 읽음
    2. AES 등으로 암호화
    3. 헤더 + 암호화된 이미지 → 커스텀 컨테이너 \`.cimg\` 또는 \`.enc\` 등의 확장자로 제공

2. **클라이언트**
    1. 컨테이너 파일 수신
    2. 헤더 파싱 후, 암호화 방식 확인
    3. **복호화** (비밀 키 필요)
    4. 복호화된 이미지 데이터를 표준 뷰어(UIImage, HTML \`\<img\>\` 등)로 디스플레이

---

## 서버 측 구현 (Node.js 예시)

### 컨테이너 포맷

**헤더 구조 (예시 총 20바이트)**

| 오프셋 | 길이 | 설명                 |
| :----: | :--: | -------------------- |
|   0    |  4   | 매직 넘버 \`"CIMG"\` |
|   4    |  4   | 버전 (정수)          |
|   8    |  4   | 암호화 방식 (정수)   |
|   12   |  8   | 예약 (0으로 채움)    |

### 암호화/복호화 로직

- **AES-256-CBC** 기준:
    - 비밀 키: 32바이트(256비트)
    - IV(초기화 벡터): 16바이트
    - 암호화 데이터: \`[IV] + [암호화된 실제 이미지 데이터]\`

### CLI 도구 예시

아래는 Node.js 환경에서 이미지 파일을 **암호화**→컨테이너 생성, **복호화**→이미지 파일 추출을 수행하는 간단한 예시 코드입니다.

> **image_container_cli.js** (발췌)

```js
#!/usr/bin/env node
const fs = require('fs');
const crypto = require('crypto');

// 암호화 방식 식별자
const EncryptionMethod = {
    NONE: 0,
    AES_CBC: 1,
};

// 이미지 → 컨테이너 (암호화)
function createContainer({ imagePath, containerPath, encryptionMethod, secretKey }) {
    const imageData = fs.readFileSync(imagePath);
    let encryptedData;

    if (encryptionMethod === EncryptionMethod.NONE) {
        // 암호화 없이 그대로
        encryptedData = imageData;
    } else if (encryptionMethod === EncryptionMethod.AES_CBC) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv('aes-256-cbc', secretKey, iv);
        encryptedData = Buffer.concat([iv, cipher.update(imageData), cipher.final()]);
    } else {
        throw new Error('지원하지 않는 암호화 방식');
    }

    // 헤더 생성 (20바이트)
    const header = Buffer.alloc(20);
    header.write('CIMG', 0, 4, 'utf8'); // 매직 넘버
    header.writeInt32BE(1, 4); // 버전 1
    header.writeInt32BE(encryptionMethod, 8); // 암호화 방식
    // 나머지 8바이트는 0 채움

    // 파일 합치기
    const containerData = Buffer.concat([header, encryptedData]);
    fs.writeFileSync(containerPath, containerData);
}

// 컨테이너 → 이미지 (복호화)
function extractImage({ containerPath, outputImagePath, secretKey }) {
    const containerData = fs.readFileSync(containerPath);

    // 헤더 읽기
    const magic = containerData.slice(0, 4).toString('utf8');
    if (magic !== 'CIMG') throw new Error('유효하지 않은 컨테이너');
    const encryptionMethod = containerData.readInt32BE(8);

    // 암호화된 데이터
    let encryptedData = containerData.slice(20);
    let imageData;

    if (encryptionMethod === EncryptionMethod.NONE) {
        imageData = encryptedData;
    } else if (encryptionMethod === EncryptionMethod.AES_CBC) {
        const iv = encryptedData.slice(0, 16);
        const actualEncrypted = encryptedData.slice(16);
        const decipher = crypto.createDecipheriv('aes-256-cbc', secretKey, iv);
        imageData = Buffer.concat([decipher.update(actualEncrypted), decipher.final()]);
    } else {
        throw new Error('지원하지 않는 암호화 방식');
    }

    fs.writeFileSync(outputImagePath, imageData);
}

// CLI 로직 (encrypt, decrypt 명령)
// ... (생략) ...
```

- **NONE**: 암호화 없이 컨테이너에 담을 수 있음
- **AES_CBC**: AES-256-CBC 적용

> **주의**: 실제 사용 시 **비밀 키**(32바이트)를 안전하게 관리해야 합니다.

---

## 클라이언트 측 구현

### iOS(Swift) 또는 Android

- **iOS(Swift)**:

    1. 서버에서 받은 컨테이너 파일(\`Data\`) 파싱
    2. 매직 넘버, 버전, 암호화 방식을 확인
    3. **CryptoKit** 등을 사용하여 복호화(AES-CBC 경우)
    4. 복호화된 \`Data\`를 \`UIImage\`로 변환해 표시

- **Android**:
    1. \`InputStream\`을 열어 바이너리 데이터를 읽고
    2. 헤더를 파싱
    3. \`Cipher.getInstance("AES/CBC/PKCS5PADDING")\` 사용
    4. 복호화된 바이트 배열을 \`BitmapFactory.decodeByteArray\`로 디코딩

### 웹 환경(HTML + JavaScript)

- **FileReader + Web Crypto API**를 사용
- **AES-CBC** 복호화를 위한 키(32바이트) 준비
- 초기화 벡터(IV)는 암호화된 데이터의 앞 16바이트
- 복호화 후 \`Blob\` → \`URL.createObjectURL\`로 \`\<img\>\`에 표시

> **HTML 예시 (요약)**

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
    </head>
    <body>
        <input type="file" id="fileInput" />
        <img id="preview" />

        <script>
            const KEY_HEX = 'f1e2...'; // 32바이트 Hex
            // 1) FileReader로 ArrayBuffer 읽기
            // 2) 헤더 파싱
            // 3) Web Crypto API로 복호화 (AES-CBC)
            // 4) Blob -> ObjectURL -> <img>에 표시
        </script>
    </body>
</html>
```

---

## 보안 고려사항

1. **키 관리**:

    - 클라이언트에 키가 노출되지 않도록 주의해야 합니다.
    - 앱 내부에 하드코딩된 키도 역공학에 취약할 수 있으므로, **서버와 안전한 통신**으로 키를 교환하거나 **토큰**을 사용하는 전략이 필요합니다.

2. **역공학 방지**:

    - 모바일 앱이나 웹 브라우저 환경에서, 결국 복호화 로직이 공개되어 있습니다.
    - 난독화(Obfuscation) 또는 각종 안티 디버깅, 루팅/탈옥 탐지 기법을 활용해 **공격 난이도**를 높일 수 있습니다.

3. **추가적인 DRM**:

    - 화면 캡쳐 방지, 워터마크 삽입, 법적 공지 등의 **복합적인 DRM 전략**이 필요할 수 있습니다.

4. **전달 방식 보안**:
    - 반드시 **HTTPS** 통신을 사용하여 네트워크 중간에서 스니핑되지 않도록 방지해야 합니다.
    - 서버 인증(토큰, OAuth 등)을 통해 인증된 사용자만 파일을 가져갈 수 있게 해야 합니다.

---

## 마무리

**이미지 DRM**을 완벽히 구현하기 위해서는 다양한 레이어의 보안 기법이 필요합니다. 여기서는 **커스텀 컨테이너 + 암호화** 방식을 통해 가장 기초적인 DRM 아이디어를 소개했습니다.

- **장점**:

    - 일반적인 뷰어로는 파일을 열 수 없어 무단 다운로드/복제 난이도 상승
    - 이미지 URL 노출 시에도 쉽게 원본을 볼 수 없음

- **한계**:
    - 복호화 로직이 결국 클라이언트에 있으므로 역공학에 대한 근본적 방어가 어렵습니다.
    - 스크린 캡처 등 다른 방식으로 유출될 수 있음

따라서 DRM을 강력히 구현하려면, **애플리케이션 레이어 보안**, **서버-클라이언트 인증 흐름**, **Tee(Trusted Execution Environment) 연동**, **FairPlay(Apple) / Widevine(Google)** 와 같은 상용 DRM 솔루션 등을 종합적으로 고려해야 합니다.

> 이 문서가 도움이 되셨다면, 댓글이나 피드백을 남겨주세요!  
> 더 궁금한 사항이 있으면 언제든지 문의 바랍니다.
17:T5a14,"use strict";
const {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];
const {useMDXComponents: _provideComponents} = arguments[0];
function _createMdxContent(props) {
  const _components = {
    blockquote: "blockquote",
    br: "br",
    code: "code",
    h1: "h1",
    h2: "h2",
    h3: "h3",
    hr: "hr",
    li: "li",
    ol: "ol",
    p: "p",
    pre: "pre",
    strong: "strong",
    table: "table",
    tbody: "tbody",
    td: "td",
    th: "th",
    thead: "thead",
    tr: "tr",
    ul: "ul",
    ..._provideComponents(),
    ...props.components
  };
  return _jsxs(_Fragment, {
    children: [_jsx(_components.h1, {
      children: "이미지 DRM 구현을 위한 커스텀 컨테이너 접근"
    }), "\n", _jsxs(_components.p, {
      children: ["이 글에서는 ", _jsx(_components.strong, {
        children: "이미지 DRM"
      }), "(Digital Rights Management)을 간단히 구현하기 위한 방법으로, ", _jsx(_components.strong, {
        children: "커스텀 컨테이너 포맷"
      }), "을 사용하는 과정을 살펴봅니다. 일반적인 PNG/JPEG 파일을 그대로 제공하면 네트워크 트래픽을 훔쳐보거나(패킷 스니핑, HTTP 후킹 등) 직접 다운로드해 무단으로 사용하는 경우가 발생할 수 있습니다. 이러한 문제를 방지하기 위해, ", _jsx(_components.strong, {
        children: "이미지를 암호화하여 커스텀 포맷으로 제공"
      }), "하고, 클라이언트(앱, 웹)에서만 복호화해 볼 수 있도록 하는 방식을 소개합니다."]
    }), "\n", _jsx(_components.h2, {
      children: "DRM 개념과 필요성"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "DRM(Digital Rights Management)"
        }), ": 디지털 콘텐츠(이미지, 동영상, 문서 등)를 무단으로 복제·배포·수정하는 행위를 방지하는 기술입니다."]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "문제 상황"
        }), ":", "\n", _jsxs(_components.ol, {
          children: ["\n", _jsx(_components.li, {
            children: "일반 JPEG/PNG로 이미지를 제공하면, 단순 URL 접근으로 다운로드가 가능합니다."
          }), "\n", _jsx(_components.li, {
            children: "네트워크 트래픽을 후킹(스니핑)하여 이미지를 추출할 수 있습니다."
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "해결 방향"
        }), ":", "\n", _jsxs(_components.ul, {
          children: ["\n", _jsxs(_components.li, {
            children: [_jsx(_components.strong, {
              children: "커스텀 포맷"
            }), " 및 ", _jsx(_components.strong, {
              children: "암호화"
            }), "를 적용하여, 표준 뷰어나 일반적인 방법으로는 파일을 열 수 없게 만듭니다."]
          }), "\n", _jsxs(_components.li, {
            children: ["클라이언트는 인증된 환경에서만 ", _jsx(_components.strong, {
              children: "복호화 키"
            }), "를 얻어 이미지를 표시할 수 있게 합니다."]
          }), "\n"]
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.hr, {}), "\n", _jsx(_components.h2, {
      children: "커스텀 컨테이너 포맷 설계"
    }), "\n", _jsx(_components.h3, {
      children: "1. 기본 구조"
    }), "\n", _jsxs(_components.p, {
      children: [_jsx(_components.strong, {
        children: "파일(컨테이너) 헤더"
      }), ":"]
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "매직 넘버"
        }), ": 파일 식별을 위한 고유 문자열, 예: `\"CIMG\"`."]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "버전"
        }), ": 포맷 버전 관리용 (정수)."]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "암호화 방식"
        }), ": AES, 기타 등등."]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "예약 영역"
        }), ": 차후 확장을 위해 남겨둔 영역."]
      }), "\n"]
    }), "\n", _jsxs(_components.p, {
      children: [_jsx(_components.strong, {
        children: "파일 바디"
      }), ":"]
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "암호화된 이미지 데이터"
        }), ": 복호화 전까진 원본 이미지를 열람할 수 없습니다."]
      }), "\n"]
    }), "\n", _jsx(_components.h3, {
      children: "2. 흐름 요약"
    }), "\n", _jsxs(_components.ol, {
      children: ["\n", _jsxs(_components.li, {
        children: ["\n", _jsx(_components.p, {
          children: _jsx(_components.strong, {
            children: "서버"
          })
        }), "\n", _jsxs(_components.ol, {
          children: ["\n", _jsx(_components.li, {
            children: "원본 이미지를 읽음"
          }), "\n", _jsx(_components.li, {
            children: "AES 등으로 암호화"
          }), "\n", _jsx(_components.li, {
            children: "헤더 + 암호화된 이미지 → 커스텀 컨테이너 `.cimg` 또는 `.enc` 등의 확장자로 제공"
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsx(_components.p, {
          children: _jsx(_components.strong, {
            children: "클라이언트"
          })
        }), "\n", _jsxs(_components.ol, {
          children: ["\n", _jsx(_components.li, {
            children: "컨테이너 파일 수신"
          }), "\n", _jsx(_components.li, {
            children: "헤더 파싱 후, 암호화 방식 확인"
          }), "\n", _jsxs(_components.li, {
            children: [_jsx(_components.strong, {
              children: "복호화"
            }), " (비밀 키 필요)"]
          }), "\n", _jsx(_components.li, {
            children: "복호화된 이미지 데이터를 표준 뷰어(UIImage, HTML `<img>` 등)로 디스플레이"
          }), "\n"]
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.hr, {}), "\n", _jsx(_components.h2, {
      children: "서버 측 구현 (Node.js 예시)"
    }), "\n", _jsx(_components.h3, {
      children: "컨테이너 포맷"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "헤더 구조 (예시 총 20바이트)"
      })
    }), "\n", _jsxs(_components.table, {
      children: [_jsx(_components.thead, {
        children: _jsxs(_components.tr, {
          children: [_jsx(_components.th, {
            style: {
              textAlign: "center"
            },
            children: "오프셋"
          }), _jsx(_components.th, {
            style: {
              textAlign: "center"
            },
            children: "길이"
          }), _jsx(_components.th, {
            children: "설명"
          })]
        })
      }), _jsxs(_components.tbody, {
        children: [_jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "0"
          }), _jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "4"
          }), _jsx(_components.td, {
            children: "매직 넘버 `\"CIMG\"`"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "4"
          }), _jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "4"
          }), _jsx(_components.td, {
            children: "버전 (정수)"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "8"
          }), _jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "4"
          }), _jsx(_components.td, {
            children: "암호화 방식 (정수)"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "12"
          }), _jsx(_components.td, {
            style: {
              textAlign: "center"
            },
            children: "8"
          }), _jsx(_components.td, {
            children: "예약 (0으로 채움)"
          })]
        })]
      })]
    }), "\n", _jsx(_components.h3, {
      children: "암호화/복호화 로직"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "AES-256-CBC"
        }), " 기준:", "\n", _jsxs(_components.ul, {
          children: ["\n", _jsx(_components.li, {
            children: "비밀 키: 32바이트(256비트)"
          }), "\n", _jsx(_components.li, {
            children: "IV(초기화 벡터): 16바이트"
          }), "\n", _jsx(_components.li, {
            children: "암호화 데이터: `[IV] + [암호화된 실제 이미지 데이터]`"
          }), "\n"]
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.h3, {
      children: "CLI 도구 예시"
    }), "\n", _jsxs(_components.p, {
      children: ["아래는 Node.js 환경에서 이미지 파일을 ", _jsx(_components.strong, {
        children: "암호화"
      }), "→컨테이너 생성, ", _jsx(_components.strong, {
        children: "복호화"
      }), "→이미지 파일 추출을 수행하는 간단한 예시 코드입니다."]
    }), "\n", _jsxs(_components.blockquote, {
      children: ["\n", _jsxs(_components.p, {
        children: [_jsx(_components.strong, {
          children: "image_container_cli.js"
        }), " (발췌)"]
      }), "\n"]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        className: "language-js",
        children: "#!/usr/bin/env node\nconst fs = require('fs');\nconst crypto = require('crypto');\n\n// 암호화 방식 식별자\nconst EncryptionMethod = {\n    NONE: 0,\n    AES_CBC: 1,\n};\n\n// 이미지 → 컨테이너 (암호화)\nfunction createContainer({ imagePath, containerPath, encryptionMethod, secretKey }) {\n    const imageData = fs.readFileSync(imagePath);\n    let encryptedData;\n\n    if (encryptionMethod === EncryptionMethod.NONE) {\n        // 암호화 없이 그대로\n        encryptedData = imageData;\n    } else if (encryptionMethod === EncryptionMethod.AES_CBC) {\n        const iv = crypto.randomBytes(16);\n        const cipher = crypto.createCipheriv('aes-256-cbc', secretKey, iv);\n        encryptedData = Buffer.concat([iv, cipher.update(imageData), cipher.final()]);\n    } else {\n        throw new Error('지원하지 않는 암호화 방식');\n    }\n\n    // 헤더 생성 (20바이트)\n    const header = Buffer.alloc(20);\n    header.write('CIMG', 0, 4, 'utf8'); // 매직 넘버\n    header.writeInt32BE(1, 4); // 버전 1\n    header.writeInt32BE(encryptionMethod, 8); // 암호화 방식\n    // 나머지 8바이트는 0 채움\n\n    // 파일 합치기\n    const containerData = Buffer.concat([header, encryptedData]);\n    fs.writeFileSync(containerPath, containerData);\n}\n\n// 컨테이너 → 이미지 (복호화)\nfunction extractImage({ containerPath, outputImagePath, secretKey }) {\n    const containerData = fs.readFileSync(containerPath);\n\n    // 헤더 읽기\n    const magic = containerData.slice(0, 4).toString('utf8');\n    if (magic !== 'CIMG') throw new Error('유효하지 않은 컨테이너');\n    const encryptionMethod = containerData.readInt32BE(8);\n\n    // 암호화된 데이터\n    let encryptedData = containerData.slice(20);\n    let imageData;\n\n    if (encryptionMethod === EncryptionMethod.NONE) {\n        imageData = encryptedData;\n    } else if (encryptionMethod === EncryptionMethod.AES_CBC) {\n        const iv = encryptedData.slice(0, 16);\n        const actualEncrypted = encryptedData.slice(16);\n        const decipher = crypto.createDecipheriv('aes-256-cbc', secretKey, iv);\n        imageData = Buffer.concat([decipher.update(actualEncrypted), decipher.final()]);\n    } else {\n        throw new Error('지원하지 않는 암호화 방식');\n    }\n\n    fs.writeFileSync(outputImagePath, imageData);\n}\n\n// CLI 로직 (encrypt, decrypt 명령)\n// ... (생략) ...\n"
      })
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "NONE"
        }), ": 암호화 없이 컨테이너에 담을 수 있음"]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "AES_CBC"
        }), ": AES-256-CBC 적용"]
      }), "\n"]
    }), "\n", _jsxs(_components.blockquote, {
      children: ["\n", _jsxs(_components.p, {
        children: [_jsx(_components.strong, {
          children: "주의"
        }), ": 실제 사용 시 ", _jsx(_components.strong, {
          children: "비밀 키"
        }), "(32바이트)를 안전하게 관리해야 합니다."]
      }), "\n"]
    }), "\n", _jsx(_components.hr, {}), "\n", _jsx(_components.h2, {
      children: "클라이언트 측 구현"
    }), "\n", _jsx(_components.h3, {
      children: "iOS(Swift) 또는 Android"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "iOS(Swift)"
          }), ":"]
        }), "\n", _jsxs(_components.ol, {
          children: ["\n", _jsx(_components.li, {
            children: "서버에서 받은 컨테이너 파일(`Data`) 파싱"
          }), "\n", _jsx(_components.li, {
            children: "매직 넘버, 버전, 암호화 방식을 확인"
          }), "\n", _jsxs(_components.li, {
            children: [_jsx(_components.strong, {
              children: "CryptoKit"
            }), " 등을 사용하여 복호화(AES-CBC 경우)"]
          }), "\n", _jsx(_components.li, {
            children: "복호화된 `Data`를 `UIImage`로 변환해 표시"
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "Android"
          }), ":"]
        }), "\n", _jsxs(_components.ol, {
          children: ["\n", _jsx(_components.li, {
            children: "`InputStream`을 열어 바이너리 데이터를 읽고"
          }), "\n", _jsx(_components.li, {
            children: "헤더를 파싱"
          }), "\n", _jsx(_components.li, {
            children: "`Cipher.getInstance(\"AES/CBC/PKCS5PADDING\")` 사용"
          }), "\n", _jsx(_components.li, {
            children: "복호화된 바이트 배열을 `BitmapFactory.decodeByteArray`로 디코딩"
          }), "\n"]
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.h3, {
      children: "웹 환경(HTML + JavaScript)"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "FileReader + Web Crypto API"
        }), "를 사용"]
      }), "\n", _jsxs(_components.li, {
        children: [_jsx(_components.strong, {
          children: "AES-CBC"
        }), " 복호화를 위한 키(32바이트) 준비"]
      }), "\n", _jsx(_components.li, {
        children: "초기화 벡터(IV)는 암호화된 데이터의 앞 16바이트"
      }), "\n", _jsx(_components.li, {
        children: "복호화 후 `Blob` → `URL.createObjectURL`로 `<img>`에 표시"
      }), "\n"]
    }), "\n", _jsxs(_components.blockquote, {
      children: ["\n", _jsx(_components.p, {
        children: _jsx(_components.strong, {
          children: "HTML 예시 (요약)"
        })
      }), "\n"]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        className: "language-html",
        children: "<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\" />\n    </head>\n    <body>\n        <input type=\"file\" id=\"fileInput\" />\n        <img id=\"preview\" />\n\n        <script>\n            const KEY_HEX = 'f1e2...'; // 32바이트 Hex\n            // 1) FileReader로 ArrayBuffer 읽기\n            // 2) 헤더 파싱\n            // 3) Web Crypto API로 복호화 (AES-CBC)\n            // 4) Blob -> ObjectURL -> <img>에 표시\n        </script>\n    </body>\n</html>\n"
      })
    }), "\n", _jsx(_components.hr, {}), "\n", _jsx(_components.h2, {
      children: "보안 고려사항"
    }), "\n", _jsxs(_components.ol, {
      children: ["\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "키 관리"
          }), ":"]
        }), "\n", _jsxs(_components.ul, {
          children: ["\n", _jsx(_components.li, {
            children: "클라이언트에 키가 노출되지 않도록 주의해야 합니다."
          }), "\n", _jsxs(_components.li, {
            children: ["앱 내부에 하드코딩된 키도 역공학에 취약할 수 있으므로, ", _jsx(_components.strong, {
              children: "서버와 안전한 통신"
            }), "으로 키를 교환하거나 ", _jsx(_components.strong, {
              children: "토큰"
            }), "을 사용하는 전략이 필요합니다."]
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "역공학 방지"
          }), ":"]
        }), "\n", _jsxs(_components.ul, {
          children: ["\n", _jsx(_components.li, {
            children: "모바일 앱이나 웹 브라우저 환경에서, 결국 복호화 로직이 공개되어 있습니다."
          }), "\n", _jsxs(_components.li, {
            children: ["난독화(Obfuscation) 또는 각종 안티 디버깅, 루팅/탈옥 탐지 기법을 활용해 ", _jsx(_components.strong, {
              children: "공격 난이도"
            }), "를 높일 수 있습니다."]
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "추가적인 DRM"
          }), ":"]
        }), "\n", _jsxs(_components.ul, {
          children: ["\n", _jsxs(_components.li, {
            children: ["화면 캡쳐 방지, 워터마크 삽입, 법적 공지 등의 ", _jsx(_components.strong, {
              children: "복합적인 DRM 전략"
            }), "이 필요할 수 있습니다."]
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "전달 방식 보안"
          }), ":"]
        }), "\n", _jsxs(_components.ul, {
          children: ["\n", _jsxs(_components.li, {
            children: ["반드시 ", _jsx(_components.strong, {
              children: "HTTPS"
            }), " 통신을 사용하여 네트워크 중간에서 스니핑되지 않도록 방지해야 합니다."]
          }), "\n", _jsx(_components.li, {
            children: "서버 인증(토큰, OAuth 등)을 통해 인증된 사용자만 파일을 가져갈 수 있게 해야 합니다."
          }), "\n"]
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.hr, {}), "\n", _jsx(_components.h2, {
      children: "마무리"
    }), "\n", _jsxs(_components.p, {
      children: [_jsx(_components.strong, {
        children: "이미지 DRM"
      }), "을 완벽히 구현하기 위해서는 다양한 레이어의 보안 기법이 필요합니다. 여기서는 ", _jsx(_components.strong, {
        children: "커스텀 컨테이너 + 암호화"
      }), " 방식을 통해 가장 기초적인 DRM 아이디어를 소개했습니다."]
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "장점"
          }), ":"]
        }), "\n", _jsxs(_components.ul, {
          children: ["\n", _jsx(_components.li, {
            children: "일반적인 뷰어로는 파일을 열 수 없어 무단 다운로드/복제 난이도 상승"
          }), "\n", _jsx(_components.li, {
            children: "이미지 URL 노출 시에도 쉽게 원본을 볼 수 없음"
          }), "\n"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.strong, {
            children: "한계"
          }), ":"]
        }), "\n", _jsxs(_components.ul, {
          children: ["\n", _jsx(_components.li, {
            children: "복호화 로직이 결국 클라이언트에 있으므로 역공학에 대한 근본적 방어가 어렵습니다."
          }), "\n", _jsx(_components.li, {
            children: "스크린 캡처 등 다른 방식으로 유출될 수 있음"
          }), "\n"]
        }), "\n"]
      }), "\n"]
    }), "\n", _jsxs(_components.p, {
      children: ["따라서 DRM을 강력히 구현하려면, ", _jsx(_components.strong, {
        children: "애플리케이션 레이어 보안"
      }), ", ", _jsx(_components.strong, {
        children: "서버-클라이언트 인증 흐름"
      }), ", ", _jsx(_components.strong, {
        children: "Tee(Trusted Execution Environment) 연동"
      }), ", ", _jsx(_components.strong, {
        children: "FairPlay(Apple) / Widevine(Google)"
      }), " 와 같은 상용 DRM 솔루션 등을 종합적으로 고려해야 합니다."]
    }), "\n", _jsxs(_components.blockquote, {
      children: ["\n", _jsxs(_components.p, {
        children: ["이 문서가 도움이 되셨다면, 댓글이나 피드백을 남겨주세요!", _jsx(_components.br, {}), "\n", "더 궁금한 사항이 있으면 언제든지 문의 바랍니다."]
      }), "\n"]
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = {
    ..._provideComponents(),
    ...props.components
  };
  return MDXLayout ? _jsx(MDXLayout, {
    ...props,
    children: _jsx(_createMdxContent, {
      ...props
    })
  }) : _createMdxContent(props);
}
return {
  default: MDXContent
};
5:[["$","$L12",null,{}],["$","$L13",null,{}],["$","$L14",null,{"title":"이미지 DRM 구현을 위한 커스텀 이미지 포맷","summary":"최근에 이미지 DRM 에 대한 관심으로, 구현 방법을 PoC 진행한 내용입니다.","date":"8 days ago","category":"coding"}],["$","$L15",null,{"post":{"slug":"image-drm-implementation","title":"이미지 DRM 구현을 위한 커스텀 이미지 포맷","date":"$D2025-01-23T04:22:06.385Z","summary":"최근에 이미지 DRM 에 대한 관심으로, 구현 방법을 PoC 진행한 내용입니다.","category":"coding","image":"https://images.pexels.com/photos/60504/security-protection-anti-virus-software-60504.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1","embeddedImagesLocal":"$undefined","tags":["dev","coding","drm","javascript"],"content":"$16","source":{"compiledSource":"$17","frontmatter":{},"scope":{}},"roadAddress":"$undefined","parcelAddress":"$undefined","lat":"$undefined","lng":"$undefined","viewCount":23}}],["$","$L18",null,{"maxWidth":"lg","sx":{"mx":"auto","width":"100%","p":2},"children":[["$","$L19",null,{"sx":{"my":3}}],["$","$L18",null,{"sx":{"mb":3},"children":["$","$L18",null,{"sx":{"mt":1,"display":"flex","flexWrap":"wrap","gap":1},"children":[["$","$L1a","0",{"href":"/tag/dev","passHref":true,"style":{"textDecoration":"none"},"children":["$","$L1b",null,{"label":"dev","sx":{"textTransform":"lowercase"}}]}],["$","$L1a","1",{"href":"/tag/coding","passHref":true,"style":{"textDecoration":"none"},"children":["$","$L1b",null,{"label":"coding","sx":{"textTransform":"lowercase"}}]}],["$","$L1a","2",{"href":"/tag/drm","passHref":true,"style":{"textDecoration":"none"},"children":["$","$L1b",null,{"label":"drm","sx":{"textTransform":"lowercase"}}]}],["$","$L1a","3",{"href":"/tag/javascript","passHref":true,"style":{"textDecoration":"none"},"children":["$","$L1b",null,{"label":"javascript","sx":{"textTransform":"lowercase"}}]}]]}]}],["$","$L18",null,{"sx":{"display":"flex","justifyContent":"space-between","alignItems":"center","flexWrap":"wrap","gap":1},"children":[["$","$L18",null,{}],["$","$L1c",null,{"component":"$1d","href":"/article/migration-to-nextjs","variant":"outlined","color":"primary","sx":{"ml":"auto","textAlign":"right"},"children":["nextjs로 이전 했습니다."," →"]}]]}]]}],["$","$L18",null,{"py":2,"mt":4,"component":"footer","children":["$","$L1e",null,{"maxWidth":"lg","sx":{"display":"flex","flexDirection":{"xs":"column","md":"row"},"justifyContent":{"xs":"center","md":"space-between"},"alignItems":"center","gap":2},"children":[["$","$L1f",null,{"variant":"body2","children":["© ","2022-2025"," ","Yeppyshiba Blog",". All rights reserved."]}],["$","$L1f",null,{"variant":"body2","children":["$","$L1d",null,{"href":"https://www.flaticon.com/free-icons/akita-inu","target":"_blank","rel":"noopener noreferrer","title":"akita inu icons","underline":"hover","color":"primary","children":"Akita inu icons created by tulpahn - Flaticon"}]}]]}]}]]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
9:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"이미지 DRM 구현을 위한 커스텀 이미지 포맷 - Yeppyshiba Blog"}],["$","meta","2",{"name":"description","content":"최근에 이미지 DRM 에 대한 관심으로, 구현 방법을 PoC 진행한 내용입니다."}],["$","meta","3",{"name":"keywords","content":"dev, coding, drm, javascript"}],["$","link","4",{"rel":"canonical","href":"/article/image-drm-implementation"}],["$","meta","5",{"property":"og:title","content":"이미지 DRM 구현을 위한 커스텀 이미지 포맷"}],["$","meta","6",{"property":"og:description","content":"최근에 이미지 DRM 에 대한 관심으로, 구현 방법을 PoC 진행한 내용입니다."}],["$","meta","7",{"property":"og:url","content":"https://blog.yeppyshiba.com/article/image-drm-implementation/"}],["$","meta","8",{"property":"og:image","content":"https://images.pexels.com/photos/60504/security-protection-anti-virus-software-60504.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1"}],["$","meta","9",{"property":"og:type","content":"website"}],["$","meta","10",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","11",{"name":"twitter:title","content":"이미지 DRM 구현을 위한 커스텀 이미지 포맷"}],["$","meta","12",{"name":"twitter:description","content":"최근에 이미지 DRM 에 대한 관심으로, 구현 방법을 PoC 진행한 내용입니다."}],["$","meta","13",{"name":"twitter:image","content":"https://images.pexels.com/photos/60504/security-protection-anti-virus-software-60504.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1"}],["$","link","14",{"rel":"icon","href":"/images/akita-inu.png"}]]
7:null
